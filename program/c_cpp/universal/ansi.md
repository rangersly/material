# ANSI转义字符归纳表

## 在代码中检测是否支持ANSI C
`#if __STDC__ == 1`

## index
- [文本样式控制](#文本样式控制)
- [color](#color)
- [光标控制](#光标控制)
- [example](#example)
  - [进度条](#进度条)
---

## **文本样式控制**
| 转义码        | 效果               | 说明                     |
|---------------|--------------------|--------------------------|
| `\033[0m`     | 重置所有样式       | 关闭所有颜色和特效       |
| `\033[1m`     | 加粗/高亮          |                          |
| `\033[2m`     | 暗淡（弱化）       | 部分终端不支持           |
| `\033[3m`     | 斜体               | 部分终端不支持           |
| `\033[4m`     | 下划线             |                          |
| `\033[5m`     | 闪烁（慢）         | 部分终端不支持           |
| `\033[7m`     | 反色（前景/背景互换）|                        |
| `\033[8m`     | 隐藏（不可见）     |                          |
| `\033[9m`     | 删除线             | 部分终端不支持           |

---

## **color**

- **前景色**
| 转义码        | 颜色      | 转义码（亮色） |
|---------------|-----------|----------------|
| `\033[30m`    | 黑色      | `\033[90m`     |
| `\033[31m`    | 红色      | `\033[91m`     |
| `\033[32m`    | 绿色      | `\033[92m`     |
| `\033[33m`    | 黄色      | `\033[93m`     |
| `\033[34m`    | 蓝色      | `\033[94m`     |
| `\033[35m`    | 品红      | `\033[95m`     |
| `\033[36m`    | 青色      | `\033[96m`     |
| `\033[37m`    | 白色      | `\033[97m`     |

- **背景色**
| 转义码        | 颜色      | 转义码（亮色） |
|---------------|-----------|----------------|
| `\033[40m`    | 黑色      | `\033[100m`    |
| `\033[41m`    | 红色      | `\033[101m`    |
| `\033[42m`    | 绿色      | `\033[102m`    |
| `\033[43m`    | 黄色      | `\033[103m`    |
| `\033[44m`    | 蓝色      | `\033[104m`    |
| `\033[45m`    | 品红      | `\033[105m`    |
| `\033[46m`    | 青色      | `\033[106m`    |
| `\033[47m`    | 白色      | `\033[107m`    |

- **RGB 颜色**
如果终端支持 **24-bit 真彩色**，可以使用：
```c
printf("\033[38;2;<r>;<g>;<b>m");  // 设置前景色（RGB）
printf("\033[48;2;<r>;<g>;<b>m");  // 设置背景色（RGB）
```

---

## **光标控制**
| 转义码                  | 作用                     |
|-------------------------|--------------------------|
| `\033[<n>A`             | 光标上移 `<n>` 行        |
| `\033[<n>B`             | 光标下移 `<n>` 行        |
| `\033[<n>C`             | 光标右移 `<n>` 列        |
| `\033[<n>D`             | 光标左移 `<n>` 列        |
| `\033[<y>;<x>H`         | 光标移动到第 `<y>` 行、第 `<x>` 列 |
| `\033[J`                | 清屏（光标以后）         |
| `\033[1J`               | 清屏（光标以前）         |
| `\033[2J`               | 清屏（整个屏幕）         |
| `\033[K`                | 清除从光标到行尾的内容   |
| `\033[1K`               | 清除从光标到行首的内容   |
| `\033[2K`               | 清除全行的内容           |
| `\033[s`                | 保存光标位置             |
| `\033[u`                | 恢复光标位置             |

---

## **example**

### **进度条**
```c
#include <stdio.h>
#include <unistd.h> // 用于 sleep 函数

// 生成 RGB 前景色 ANSI 代码（需确保缓冲区足够大）
#define GET_RGB(buf,size,r,g,b) do{snprintf(buf, (size), "\033[38;2;%d;%d;%dm", (r), (g), (b));}while(0)

void update_progress(int percent) {
    char color[32];
    // 根据进度改变颜色（红色 -> 黄色 -> 绿色）
    GET_RGB(color, sizeof(color), 255 * (100 - percent) / 100, 255 * percent / 100, 0);

    // 绘制进度条
    printf("\r%s[", color);
    for (int i = 0; i < 50; i++)
        printf(i < percent / 2 ? "█" : " ");
    printf("] %d%%\033[0m", percent);
    fflush(stdout); // 强制刷新输出
}

int main() {
    for (int i = 0; i <= 100; i++) {
        update_progress(i);
        usleep(50000);
    }
    putchar('\n');
    return 0;
}
```
